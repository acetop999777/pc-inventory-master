diff --git a/client/src/AppLegacy.tsx b/client/src/AppLegacy.tsx
index 4a86d5bf..811b12fe 100644
--- a/client/src/AppLegacy.tsx
+++ b/client/src/AppLegacy.tsx
@@ -29,7 +29,8 @@ export default function AppLegacy() {
   const [subView, setSubView] = useState<'list' | 'detail'>('list');
 
   const [activeClientId, setActiveClientId] = useState<string | null>(null);
-  // draft 仅用于“新建但尚未首次落库”的 client（属于 client state）
+
+  // draft：只用于“新建但尚未首次落库”的 client（属于纯 client state）
   const [draftClient, setDraftClient] = useState<ClientEntity | null>(null);
 
   const fileRef = useRef<HTMLInputElement>(null);
@@ -43,7 +44,7 @@ export default function AppLegacy() {
   const { update: updateClient, remove: removeClient } = useClientWriteBehind();
   const { queue, snapshot } = useSaveQueue();
 
-  // draft 一旦首次保存成功（进入 clients query cache），就切回“server state 唯一真相”
+  // draft 一旦进入 clients cache（意味着至少保存成功一次），就自动清掉 draft
   useEffect(() => {
     if (!draftClient) return;
     if (clients.some((c) => c.id === draftClient.id)) setDraftClient(null);
@@ -61,31 +62,27 @@ export default function AppLegacy() {
     return snapshot.keys.find((k) => k.key === activeKey) ?? null;
   }, [snapshot, activeKey]);
 
-  const pending = Boolean(keyStatus?.pending);
-  const inFlight = Boolean(keyStatus?.inFlight);
+  const busy = Boolean(keyStatus?.pending || keyStatus?.inFlight);
   const hasError = Boolean(keyStatus?.hasError);
-  const busy = pending || inFlight;
 
-  // “Saved” 只在刚同步完成时短暂闪一下；idle 时不常驻
+  // busy -> idle：短暂闪一下 Saved（idle 时不常驻）
   const [flashSaved, setFlashSaved] = useState(false);
-  const savedTimerRef = useRef<any>(null);
-  const prevBusyRef = useRef<boolean>(false);
-
-  useEffect(() => {
-    // key 切换：重置
-    prevBusyRef.current = false;
-    setFlashSaved(false);
-    if (savedTimerRef.current) clearTimeout(savedTimerRef.current);
-  }, [activeKey]);
+  const prevBusyRef = useRef(false);
+  const tRef = useRef<any>(null);
 
   useEffect(() => {
     const prev = prevBusyRef.current;
+    prevBusyRef.current = busy;
+
     if (activeKey && prev && !busy && !hasError) {
       setFlashSaved(true);
-      if (savedTimerRef.current) clearTimeout(savedTimerRef.current);
-      savedTimerRef.current = setTimeout(() => setFlashSaved(false), 900);
+      if (tRef.current) clearTimeout(tRef.current);
+      tRef.current = setTimeout(() => setFlashSaved(false), 900);
+      return;
     }
-    prevBusyRef.current = busy;
+
+    if (hasError) setFlashSaved(false);
+    if (!busy && !hasError) setFlashSaved(false);
   }, [busy, hasError, activeKey]);
 
   const handleNewClient = useCallback(() => {
@@ -107,7 +104,7 @@ export default function AppLegacy() {
     async (id: string, name: string) => {
       if (!window.confirm(`Delete ${name}?`)) return;
 
-      // 如果正在编辑该 client：先返回列表（避免 detail 里引用失效）
+      // 若正在看 detail：先回列表，避免 detail 继续引用
       if (activeClientId === id) {
         setSubView('list');
         setActiveClientId(null);
@@ -123,7 +120,7 @@ export default function AppLegacy() {
     (field: keyof ClientEntity, val: any) => {
       if (!activeClientId) return;
 
-      // draft：先更新本地 draft（client state），并把 draft 作为 base 交给 write-behind
+      // draft：先更新本地 draft，然后把 base 交给 write-behind，确保首次写回有完整对象
       if (draftClient && draftClient.id === activeClientId) {
         const next: ClientEntity = { ...draftClient, [field]: val };
         setDraftClient(next);
@@ -147,7 +144,6 @@ export default function AppLegacy() {
       if (mainView === 'clients' && subView === 'detail' && activeKey) {
         await queue.flushKey(activeKey);
 
-        // flush 后检查状态（注意：SaveQueue 在 error 时不会 throw）
         const post = queue.getSnapshot().keys.find((k) => k.key === activeKey);
         const blocked = post ? post.hasError || post.pending || post.inFlight : false;
 
@@ -161,6 +157,11 @@ export default function AppLegacy() {
     [activeKey, mainView, queue, subView]
   );
 
+  const financials = useMemo(
+    () => (activeClient ? calculateFinancials(activeClient) : { totalCost: 0, profit: 0, balanceDue: 0, isPaidOff: false }),
+    [activeClient]
+  );
+
   const renderContent = () => {
     if (mainView === 'dashboard') return <Dashboard />;
     if (mainView === 'inventory') return <InventoryHub />;
@@ -178,54 +179,58 @@ export default function AppLegacy() {
         );
       }
 
-      // detail
-      if (!activeClient) return <div className="p-10">Loading...</div>;
-      const financials = calculateFinancials(activeClient);
+      if (subView === 'detail') {
+        if (!activeClient) return <div className="p-10">Loading...</div>;
 
-      return (
-        <div className="min-h-screen bg-slate-50">
-          <div className="p-6 pb-0">
-            <div className="flex items-center justify-between max-w-[1600px] mx-auto">
-              <div className="flex items-center gap-3">
+        return (
+          <div className="min-h-screen pb-40 animate-in slide-in-from-right duration-300">
+            <div className="bg-white border-b border-slate-200 px-6 py-3 flex justify-between items-center sticky top-0 z-40">
+              <div className="flex items-center gap-4">
                 <button
-                  onClick={() => void flushAndGo(() => setSubView('list'))}
+                  onClick={() =>
+                    void flushAndGo(() => {
+                      setSubView('list');
+                      setActiveClientId(null);
+                      // draft 若没成功落库，返回列表即丢弃（不会“幽灵占位”）
+                      setDraftClient(null);
+                    })
+                  }
                   className="text-slate-500 hover:text-slate-800 transition-colors"
                   title={busy ? 'Syncing before leaving…' : hasError ? 'Sync failed' : 'Back'}
                 >
                   <ChevronLeft size={20} />
                 </button>
                 <div className="h-6 w-px bg-slate-200"></div>
-                <span className="font-black text-lg text-slate-800">
-                  {activeClient.wechatName || 'New Client'}
-                </span>
+                <span className="font-black text-lg text-slate-800">{activeClient.wechatName || 'New Client'}</span>
               </div>
 
-              <div className="flex items-center gap-2">
-                {hasError && (
-                  <>
-                    <button
-                      onClick={retryActive}
-                      className="text-xs font-black px-3 py-2 rounded-xl border border-amber-300 bg-amber-50 text-amber-800 active:scale-95 transition-transform"
-                      title="Retry sync"
-                    >
-                      <span className="inline-flex items-center gap-2">
-                        <AlertTriangle size={16} /> Retry
-                      </span>
-                    </button>
-                  </>
-                )}
-
-                {(busy || flashSaved || hasError) && (
-                  <div className="flex items-center gap-2 text-xs font-black text-slate-700">
-                    {busy && <Loader2 className="animate-spin" size={16} />}
-                    {!busy && !hasError && flashSaved && <CheckCircle2 size={16} className="text-emerald-600" />}
-                    {!busy && hasError && <AlertTriangle size={16} className="text-amber-600" />}
-                    <span>
-                      {busy ? 'Syncing...' : hasError ? 'Sync failed' : 'Saved'}
-                    </span>
-                  </div>
-                )}
-              </div>
+              {(busy || hasError || flashSaved) && (
+                <div className="flex items-center gap-2 px-3 py-1.5 rounded-full bg-slate-50 text-[10px] font-bold uppercase tracking-wider text-slate-400">
+                  {hasError ? (
+                    <>
+                      <AlertTriangle size={12} className="text-amber-600" />
+                      <span className="text-amber-700">Needs Sync</span>
+                      <button
+                        onClick={retryActive}
+                        className="ml-2 px-2 py-1 rounded-full bg-white border border-amber-200 hover:bg-amber-50 text-amber-700"
+                        title="Retry"
+                      >
+                        Retry
+                      </button>
+                    </>
+                  ) : busy ? (
+                    <>
+                      <Loader2 size={12} className="animate-spin text-blue-500" />
+                      <span>Syncing...</span>
+                    </>
+                  ) : (
+                    <>
+                      <CheckCircle2 size={12} className="text-emerald-500" />
+                      <span className="text-emerald-700">Saved</span>
+                    </>
+                  )}
+                </div>
+              )}
             </div>
 
             <div className="max-w-[1600px] mx-auto p-6 grid grid-cols-12 gap-6">
@@ -246,8 +251,8 @@ export default function AppLegacy() {
               </div>
             </div>
           </div>
-        </div>
-      );
+        );
+      }
     }
 
     return <div className="p-10">Loading...</div>;
@@ -260,6 +265,8 @@ export default function AppLegacy() {
         void flushAndGo(() => {
           setMainView(view);
           setSubView('list');
+          setActiveClientId(null);
+          setDraftClient(null);
         });
       }}
     >
diff --git a/client/src/app/queries/clients.ts b/client/src/app/queries/clients.ts
index 395cdadc..f451016f 100644
--- a/client/src/app/queries/clients.ts
+++ b/client/src/app/queries/clients.ts
@@ -4,14 +4,57 @@ import { ClientEntity } from '../../domain/client/client.types';
 
 export const clientsQueryKey = ['clients'] as const;
 
-async function fetchClients(): Promise<ClientEntity[]> {
-  const data = await apiCallOrThrow<ClientEntity[]>('/clients');
-  return Array.isArray(data) ? data : [];
+function tryParseJsonObject(x: any): any {
+  if (x == null) return {};
+  if (typeof x === 'object') return x;
+  if (typeof x === 'string') {
+    try {
+      const v = JSON.parse(x);
+      return typeof v === 'object' && v != null ? v : {};
+    } catch {
+      return {};
+    }
+  }
+  return {};
+}
+
+export function normalizeClientRow(row: any): ClientEntity {
+  return {
+    id: String(row?.id ?? ''),
+    wechatName: String(row?.wechatName ?? ''),
+    wechatId: String(row?.wechatId ?? ''),
+    realName: String(row?.realName ?? ''),
+    xhsName: String(row?.xhsName ?? ''),
+    xhsId: String(row?.xhsId ?? ''),
+    rating: Number(row?.rating ?? 0) || 0,
+    notes: String(row?.notes ?? ''),
+    photos: Array.isArray(row?.photos) ? row.photos : [],
+
+    status: String(row?.status ?? 'Pending'),
+    orderDate: String(row?.orderDate ?? ''),
+    deliveryDate: String(row?.deliveryDate ?? ''),
+    isShipping: Boolean(row?.isShipping),
+    trackingNumber: String(row?.trackingNumber ?? ''),
+    address: String(row?.address ?? ''),
+    city: String(row?.city ?? ''),
+    state: String(row?.state ?? ''),
+    zip: String(row?.zip ?? ''),
+
+    totalPrice: Number(row?.totalPrice ?? 0) || 0,
+    paidAmount: Number(row?.paidAmount ?? 0) || 0,
+
+    specs: tryParseJsonObject(row?.specs),
+    pcppLink: String(row?.pcppLink ?? ''),
+  };
 }
 
 export function useClientsQuery() {
-  return useQuery({
+  return useQuery<ClientEntity[]>({
     queryKey: clientsQueryKey,
-    queryFn: fetchClients,
+    queryFn: async () => {
+      const raw = await apiCallOrThrow<any>('/clients');
+      const arr = Array.isArray(raw) ? raw : [];
+      return arr.map(normalizeClientRow);
+    },
   });
 }
diff --git a/client/src/app/writeBehind/clientWriteBehind.ts b/client/src/app/writeBehind/clientWriteBehind.ts
index 383d0b19..c101de4f 100644
--- a/client/src/app/writeBehind/clientWriteBehind.ts
+++ b/client/src/app/writeBehind/clientWriteBehind.ts
@@ -6,19 +6,15 @@ import { clientsQueryKey } from '../queries/clients';
 import { useSaveQueue } from '../saveQueue/SaveQueueProvider';
 
 type ClientWrite =
-  | { op: 'upsert'; fields: Partial<ClientEntity>; base?: ClientEntity }
+  | { op: 'patch'; fields: Partial<ClientEntity> }
   | { op: 'delete' };
 
 function mergeClientWrite(a: ClientWrite, b: ClientWrite): ClientWrite {
   if (a.op === 'delete' || b.op === 'delete') return { op: 'delete' };
-  return {
-    op: 'upsert',
-    fields: { ...a.fields, ...b.fields },
-    base: b.base ?? a.base,
-  };
+  return { op: 'patch', fields: { ...a.fields, ...b.fields } };
 }
 
-function coerce(fields: Partial<ClientEntity>): Partial<ClientEntity> {
+function coerceFields(fields: Partial<ClientEntity>): Partial<ClientEntity> {
   const f: any = { ...fields };
   if (Object.prototype.hasOwnProperty.call(f, 'totalPrice')) f.totalPrice = Number(f.totalPrice ?? 0);
   if (Object.prototype.hasOwnProperty.call(f, 'paidAmount')) f.paidAmount = Number(f.paidAmount ?? 0);
@@ -27,35 +23,39 @@ function coerce(fields: Partial<ClientEntity>): Partial<ClientEntity> {
   return f;
 }
 
-function upsertInList(old: ClientEntity[], id: string, next: ClientEntity): ClientEntity[] {
-  const has = old.some((c) => c.id === id);
-  if (!has) return [next, ...old];
-  return old.map((c) => (c.id === id ? { ...c, ...next } : c));
+function upsert(list: ClientEntity[], next: ClientEntity): ClientEntity[] {
+  const i = list.findIndex((c) => c.id === next.id);
+  if (i === -1) return [next, ...list];
+  const copy = list.slice();
+  copy[i] = { ...copy[i], ...next };
+  return copy;
 }
 
 export function useClientWriteBehind() {
   const qc = useQueryClient();
   const { queue } = useSaveQueue();
 
-  const applyOptimisticIfExists = (id: string, fields: Partial<ClientEntity>) => {
-    const nextFields = coerce(fields);
+  const applyOptimistic = (id: string, fields: Partial<ClientEntity>, base?: ClientEntity) => {
+    const nextFields = coerceFields(fields);
     qc.setQueryData<ClientEntity[]>(clientsQueryKey, (old = []) => {
-      if (!old.some((c) => c.id === id)) return old;
-      return old.map((c) => (c.id === id ? { ...c, ...nextFields } : c));
+      const cur = old.find((c) => c.id === id) ?? base;
+      if (!cur) return old;
+      const merged: ClientEntity = { ...cur, ...nextFields };
+      return upsert(old, merged);
     });
   };
 
-  const removeOptimisticIfExists = (id: string) => {
+  const removeOptimistic = (id: string) => {
     qc.setQueryData<ClientEntity[]>(clientsQueryKey, (old = []) => old.filter((c) => c.id !== id));
   };
 
   const update = (id: string, fields: Partial<ClientEntity>, base?: ClientEntity) => {
-    applyOptimisticIfExists(id, fields);
+    applyOptimistic(id, fields, base);
 
     void queue.enqueue<ClientWrite>({
       key: `client:${id}`,
       label: 'Clients',
-      patch: { op: 'upsert', fields: coerce(fields), base },
+      patch: { op: 'patch', fields: coerceFields(fields) },
       merge: mergeClientWrite,
       write: async (w) => {
         if (w.op === 'delete') {
@@ -64,10 +64,10 @@ export function useClientWriteBehind() {
         }
 
         const list = qc.getQueryData<ClientEntity[]>(clientsQueryKey) ?? [];
-        const current = list.find((c) => c.id === id) ?? w.base;
-        if (!current) throw new Error(`Client not found in cache; base required for id=${id}`);
+        const cur = list.find((c) => c.id === id) ?? base;
+        if (!cur) throw new Error(`Client not found in cache; base required for id=${id}`);
 
-        const merged: ClientEntity = { ...current, ...w.fields };
+        const merged: ClientEntity = { ...cur, ...w.fields };
         const fin = calculateFinancials(merged);
 
         await apiCallOrThrow('/clients', 'POST', {
@@ -76,14 +76,14 @@ export function useClientWriteBehind() {
           profit: fin.profit,
         });
 
-        qc.setQueryData<ClientEntity[]>(clientsQueryKey, (old = []) => upsertInList(old, id, merged));
+        qc.setQueryData<ClientEntity[]>(clientsQueryKey, (old = []) => upsert(old, merged));
       },
       debounceMs: 700,
     });
   };
 
   const remove = (id: string) => {
-    removeOptimisticIfExists(id);
+    removeOptimistic(id);
     void queue.enqueue<ClientWrite>({
       key: `client:${id}`,
       label: 'Clients',
