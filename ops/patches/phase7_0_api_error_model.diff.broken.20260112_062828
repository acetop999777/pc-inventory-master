diff --git a/client/src/utils.ts b/client/src/utils.ts
--- a/client/src/utils.ts
+++ b/client/src/utils.ts
@@ -1,200 +1,260 @@
 import { InventoryItem } from './types';
 
 export const API_BASE = `http://${window.location.hostname}:5001/api`;
 export const generateId = (): string => Math.random().toString(36).substr(2, 9);
 export const formatMoney = (n: number | undefined): string => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(n || 0);
@@
 export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
 
+export type ApiErrorKind = 'NETWORK' | 'TIMEOUT' | 'HTTP' | 'PARSE' | 'UNKNOWN';
+
+// Contract: date-only string "YYYY-MM-DD" (server/client 都以此为准)
+export function toDateOnly(v: unknown): string {
+    const s = String(v ?? '');
+    if (!s) return '';
+    // already date-only
+    if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
+    // ISO timestamp -> date-only
+    if (s.length >= 10 && /^\d{4}-\d{2}-\d{2}T/.test(s)) return s.slice(0, 10);
+    // fallback: try Date parse
+    const d = new Date(s);
+    if (Number.isNaN(d.getTime())) return '';
+    return d.toISOString().slice(0, 10);
+}
+
 export class ApiCallError extends Error {
     url: string;
+    method: HttpMethod;
+    kind: ApiErrorKind;
     status?: number;
     responseBody?: unknown;
+    retriable: boolean;
+    userMessage: string;
 
-    constructor(message: string, url: string, status?: number, responseBody?: unknown) {
+    constructor(args: {
+        message: string;
+        url: string;
+        method: HttpMethod;
+        kind: ApiErrorKind;
+        status?: number;
+        responseBody?: unknown;
+        retriable: boolean;
+        userMessage: string;
+    }) {
+        super(args.message);
         super(message);
         this.name = 'ApiCallError';
-        this.url = url;
-        this.status = status;
-        this.responseBody = responseBody;
+        this.url = args.url;
+        this.method = args.method;
+        this.kind = args.kind;
+        this.status = args.status;
+        this.responseBody = args.responseBody;
+        this.retriable = args.retriable;
+        this.userMessage = args.userMessage;
     }
 }
 
 async function parseResponseBody(res: Response): Promise<unknown> {
     const ct = res.headers.get('content-type') || '';
     try {
+        if (res.status === 204) return null;
         if (ct.includes('application/json')) return await res.json();
         return await res.text();
     } catch {
         return null;
     }
 }
 
+function guessRetriableFromStatus(status?: number): boolean {
+    if (!status) return true;
+    // network-like HTTP statuses
+    if (status === 408 || status === 429) return true;
+    if (status >= 500) return true;
+    // 409 通常需要用户刷新/重试
+    if (status === 409) return true;
+    return false;
+}
+
+function extractUserMessage(kind: ApiErrorKind, status: number | undefined, body: unknown): string {
+    // server 若返回 { error: { message } }，优先用它
+    const anyBody: any = body as any;
+    const m =
+        anyBody?.error?.message ??
+        anyBody?.message ??
+        (typeof anyBody === 'string' ? anyBody : null);
+
+    if (m && typeof m === 'string') return m.slice(0, 300);
+
+    if (kind === 'TIMEOUT') return 'Request timed out';
+    if (kind === 'NETWORK') return 'Network error (server unreachable)';
+    if (kind === 'HTTP') return status ? `Request failed (${status})` : 'Request failed';
+    return 'Request failed';
+}
+
 /**
  * Strict API: throws on network error or non-2xx response.
  * Use this for React Query / mutations so errors are properly tracked.
  */
 export async function apiCallOrThrow<T>(
     url: string,
     method: HttpMethod = 'GET',
     body: any = null,
-    opts: { signal?: AbortSignal } = {}
+    opts: { signal?: AbortSignal; timeoutMs?: number } = {}
 ): Promise<T> {
-    const init: RequestInit = {
-        method,
-        headers: { 'Content-Type': 'application/json' },
-        signal: opts.signal,
-    };
-    if (body !== null && body !== undefined) init.body = JSON.stringify(body);
-
-    const res = await fetch(`${API_BASE}${url}`, init);
-    const data = await parseResponseBody(res);
-
-    if (!res.ok) {
-        throw new ApiCallError(`API ${method} ${url} failed`, url, res.status, data);
-    }
-    return data as T;
+    const init: RequestInit = { method, headers: { 'Accept': 'application/json' } };
+    if (body !== null && body !== undefined) {
+        (init.headers as any)['Content-Type'] = 'application/json';
+        init.body = JSON.stringify(body);
+    }
+
+    // 默认超时（避免 SaveQueue 永久挂起）
+    const timeoutMs = opts.timeoutMs ?? 12000;
+    let timer: any = null;
+    let localAbort: AbortController | null = null;
+
+    if (opts.signal) {
+        init.signal = opts.signal;
+    } else {
+        localAbort = new AbortController();
+        init.signal = localAbort.signal;
+        timer = setTimeout(() => localAbort?.abort(), timeoutMs);
+    }
+
+    try {
+        const res = await fetch(`${API_BASE}${url}`, init);
+        const data = await parseResponseBody(res);
+
+        if (!res.ok) {
+            const status = res.status;
+            throw new ApiCallError({
+                message: `API ${method} ${url} failed`,
+                url,
+                method,
+                kind: 'HTTP',
+                status,
+                responseBody: data,
+                retriable: guessRetriableFromStatus(status),
+                userMessage: extractUserMessage('HTTP', status, data),
+            });
+        }
+        return data as T;
+    } catch (e: any) {
+        const isAbort = e?.name === 'AbortError';
+        const kind: ApiErrorKind = isAbort ? 'TIMEOUT' : 'NETWORK';
+        const status = undefined;
+        throw e instanceof ApiCallError
+            ? e
+            : new ApiCallError({
+                message: `API ${method} ${url} failed`,
+                url,
+                method,
+                kind,
+                status,
+                responseBody: null,
+                retriable: true,
+                userMessage: extractUserMessage(kind, status, null),
+            });
+    } finally {
+        if (timer) clearTimeout(timer);
+    }
 }
diff --git a/client/src/app/saveQueue/SyncStatusPill.tsx b/client/src/app/saveQueue/SyncStatusPill.tsx
--- a/client/src/app/saveQueue/SyncStatusPill.tsx
+++ b/client/src/app/saveQueue/SyncStatusPill.tsx
@@ -1,120 +1,170 @@
 import React, { useSyncExternalStore } from 'react';
 import { CheckCircle2, Loader2, AlertTriangle } from 'lucide-react';
 import { useSaveQueue } from './SaveQueueProvider';
 
 export function SyncStatusPill() {
   const { queue } = useSaveQueue();
 
   const snap = useSyncExternalStore(
     queue.subscribe,
     () => queue.getSnapshot(),
     () => queue.getSnapshot()
   );
 
   const busy = (snap.pendingCount + snap.inFlightCount) > 0;
   const hasError = snap.errorCount > 0;
 
+  const errorKeys = snap.keys.filter((k) => k.hasError);
+  const topErr: any = errorKeys[0]?.lastError as any;
+
+  const topErrMsg =
+    topErr?.userMessage ??
+    topErr?.message ??
+    (typeof topErr === 'string' ? topErr : '') ??
+    '';
+  const topErrKind = topErr?.kind;
+  const topErrStatus = topErr?.status;
+
+  const errorTitle = (() => {
+    if (!hasError) return '';
+    const head = [
+      topErrKind ? String(topErrKind) : 'ERROR',
+      topErrStatus ? String(topErrStatus) : null,
+    ].filter(Boolean).join(' ');
+    const body = topErrMsg ? `: ${topErrMsg}` : '';
+    return (head + body).slice(0, 240);
+  })();
+
+  // 只有 error 明确标记 retriable=false 时才认为不可重试；否则保守认为可重试
+  const anyRetriable = errorKeys.some((k) => (k.lastError as any)?.retriable !== false);
+
   const [showSaved, setShowSaved] = React.useState(false);
   const prevBusyRef = React.useRef(false);
   const tRef = React.useRef<any>(null);
 
   React.useEffect(() => {
     const prevBusy = prevBusyRef.current;
     prevBusyRef.current = busy;
 
     // busy -> idle：短暂显示 Saved
     if (prevBusy && !busy && !hasError) {
       setShowSaved(true);
       if (tRef.current) clearTimeout(tRef.current);
       tRef.current = setTimeout(() => setShowSaved(false), 900);
       return;
     }
 
     // 有错误：不显示 Saved
     if (hasError) setShowSaved(false);
 
     // idle 且无错误：不显示任何东西
     if (!busy && !hasError) setShowSaved(false);
   }, [busy, hasError]);
 
   // ✅ 关键：idle 时不渲染（彻底去掉“常驻 Saved”）
   if (!busy && !hasError && !showSaved) return null;
 
   const retryAll = () => {
     void queue.flushAll({ timeoutMs: 8000 });
   };
 
   return (
     <div className="fixed top-4 right-4 z-[999]">
       <div
         className={[
           "flex items-center gap-2 px-4 py-2 rounded-full border shadow-sm",
           "text-[10px] font-black uppercase tracking-wider",
           hasError
             ? "bg-red-50 border-red-200 text-red-700"
             : busy
               ? "bg-slate-50 border-slate-200 text-slate-600"
               : "bg-emerald-50 border-emerald-200 text-emerald-700"
         ].join(" ")}
+        title={hasError ? errorTitle : undefined}
       >
         {hasError ? (
           <>
             <AlertTriangle size={14} />
             <span>Needs Sync</span>
-            <button
-              onClick={retryAll}
-              className="ml-2 px-2 py-1 rounded-full bg-white border border-red-200 hover:bg-red-50"
-              title="Retry pending saves"
-            >
-              Retry
-            </button>
+            {anyRetriable ? (
+              <button
+                onClick={retryAll}
+                className="ml-2 px-2 py-1 rounded-full bg-white border border-red-200 hover:bg-red-50"
+                title="Retry pending saves"
+              >
+                Retry
+              </button>
+            ) : (
+              <span className="ml-2 px-2 py-1 rounded-full bg-white border border-red-200">
+                Fix & retry
+              </span>
+            )}
           </>
         ) : busy ? (
           <>
             <Loader2 size={14} className="animate-spin" />
             <span>Syncing...</span>
           </>
         ) : (
           <>
             <CheckCircle2 size={14} />
             <span>Saved</span>
           </>
         )}
       </div>
     </div>
   );
 }
 
 export default SyncStatusPill;
