import React, { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';
import { useNavigate, useParams } from 'react-router-dom';

import { ClientEntity } from '../../domain/client/client.types';
import { calculateFinancials, createEmptyClient } from '../../domain/client/client.logic';
import { generateId } from '../../utils';

import { useClientsQuery } from '../../app/queries/clients';
import { useInventoryQuery } from '../../app/queries/inventory';
import { useClientWriteBehind } from '../../app/writeBehind/clientWriteBehind';
import { useSaveQueue } from '../../app/saveQueue/SaveQueueProvider';
import { useNavigationGuard } from '../../app/navigation/NavigationGuard';

import { ClientsListPage } from './ClientsListPage';
import { ClientDetailPage } from './ClientDetailPage';

const STATUS_STEPS = ['Pending', 'Deposit', 'Building', 'Ready', 'Delivered'] as const;

// --- Draft store (in-memory only; refresh = wipe) ---
type DraftCtx = {
  getDraft: (id: string) => ClientEntity | null;
  setDraft: (id: string, c: ClientEntity) => void;
  clearDraft: (id: string) => void;
};

const DraftContext = createContext<DraftCtx | null>(null);

function DraftProvider({ children }: { children: React.ReactNode }) {
  const [drafts, setDrafts] = useState<Record<string, ClientEntity>>({});

  const getDraft = useCallback((id: string) => drafts[id] ?? null, [drafts]);

  const setDraft = useCallback((id: string, c: ClientEntity) => {
    setDrafts((prev) => ({ ...prev, [id]: c }));
  }, []);

  const clearDraft = useCallback((id: string) => {
    setDrafts((prev) => {
      if (!prev[id]) return prev;
      const copy = { ...prev };
      delete copy[id];
      return copy;
    });
  }, []);

  const value = useMemo(() => ({ getDraft, setDraft, clearDraft }), [getDraft, setDraft, clearDraft]);
  return <DraftContext.Provider value={value}>{children}</DraftContext.Provider>;
}

function useDraftStore() {
  const ctx = useContext(DraftContext);
  if (!ctx) throw new Error('useDraftStore must be used within DraftProvider');
  return ctx;
}

function isNonEmptyName(v: any) {
  return typeof v === 'string' && v.trim().length > 0;
}

// UI 输入经常会给 number 字段塞 string，这里统一收敛：空/非法 -> 0；负数 -> 0
function coerceNonNegNumber(v: any) {
  if (v === null || v === undefined) return 0;
  if (typeof v === 'number') return Number.isFinite(v) && v > 0 ? v : 0;
  const s = String(v).trim();
  if (!s) return 0;
  const n = Number(s);
  if (!Number.isFinite(n)) return 0;
  return n >= 0 ? n : 0;
}

function normalizeField(field: keyof ClientEntity, val: any): any {
  if (field === 'totalPrice') return coerceNonNegNumber(val);
  if (field === 'paidAmount') return coerceNonNegNumber(val);
  if (field === 'rating') return coerceNonNegNumber(val);
  if (field === 'isShipping') return Boolean(val);
  return val;
}

export function ClientsListRoute() {
  const nav = useNavigate();
  const { data } = useClientsQuery();
  const clients = data ?? [];
  const { remove } = useClientWriteBehind();
  const { setDraft } = useDraftStore();

  const onNewClient = useCallback(() => {
    // 只创建内存草稿：不落库、不进 query cache（避免幽灵记录）
    const c = createEmptyClient();
    c.id = generateId();
    setDraft(c.id, c);
    nav(`/clients/${c.id}`);
  }, [nav, setDraft]);

  const onSelectClient = useCallback(
    (c: ClientEntity) => {
      nav(`/clients/${c.id}`);
    },
    [nav]
  );

  const onDeleteClient = useCallback(
    async (id: string, name: string) => {
      if (!window.confirm(`Delete ${name}?`)) return;
      remove(id);
    },
    [remove]
  );

  return (
    <ClientsListPage clients={clients} onSelectClient={onSelectClient} onNewClient={onNewClient} onDeleteClient={onDeleteClient} />
  );
}

export function ClientDetailRoute() {
  const nav = useNavigate();
  const { id } = useParams();
  const clientId = String(id ?? '');

  const activeKey = clientId ? `client:${clientId}` : null;

  const { data: clientsData } = useClientsQuery();
  const clients = clientsData ?? [];

  const { data: invData } = useInventoryQuery();
  const inventory = invData ?? [];

  const { update: updateClient } = useClientWriteBehind();
  const { queue, snapshot } = useSaveQueue();
  const guard = useNavigationGuard();

  const { getDraft, setDraft, clearDraft } = useDraftStore();
  const draft = clientId ? getDraft(clientId) : null;

  const fromCache = useMemo(() => {
    if (!clientId) return null;
    return clients.find((c) => c.id === clientId) ?? null;
  }, [clients, clientId]);

  // draft-only：存在 draft 且 cache 里还没有（即未落库/未进入列表）
  const isDraftOnly = Boolean(draft && !fromCache);

  const activeClient: ClientEntity | null = draft ?? fromCache;

  // 一旦进入 cache（意味着已触发落库/进入“正式对象”），就清掉 draft
  useEffect(() => {
    if (!clientId || !draft) return;
    if (clients.some((c) => c.id === clientId)) clearDraft(clientId);
  }, [clientId, clients, clearDraft, draft]);

  // 关键：离开 detail 时，如果还停留在 draft-only（wechatName 还没触发落库），直接丢弃草稿
  useEffect(() => {
    return () => {
      if (!clientId) return;
      const d = getDraft(clientId);
      const exists = clients.some((c) => c.id === clientId);
      // 只在“未落库”时丢弃（刷新/退出即作废）
      if (d && !exists) clearDraft(clientId);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [clientId]);

  const keyStatus = useMemo(() => {
    if (!activeKey) return null;
    return snapshot.keys.find((k) => k.key === activeKey) ?? null;
  }, [snapshot.keys, activeKey]);

  const busy = Boolean(keyStatus?.pending || keyStatus?.inFlight);
  const hasError = Boolean(keyStatus?.hasError);

  // busy->idle Saved flash
  const [flashSaved, setFlashSaved] = useState(false);
  const prevBusyRef = useRef(false);
  const tRef = useRef<any>(null);

  useEffect(() => {
    const prev = prevBusyRef.current;
    prevBusyRef.current = busy;

    if (activeKey && prev && !busy && !hasError) {
      setFlashSaved(true);
      if (tRef.current) clearTimeout(tRef.current);
      tRef.current = setTimeout(() => setFlashSaved(false), 900);
      return;
    }

    if (hasError) setFlashSaved(false);
    if (!busy && !hasError) setFlashSaved(false);
  }, [busy, hasError, activeKey]);

  const commitDraftIfReady = useCallback(
    async (next: ClientEntity) => {
      if (!activeKey) return;
      if (!isNonEmptyName(next.wechatName)) return;
      // 已经在 cache 里就不重复 commit
      if (clients.some((c) => c.id === clientId)) return;

      // 用“全量对象”落库一次：把之前缓存的所有字段一起提交
      updateClient(clientId, { ...next } as Partial<ClientEntity>, next);

      // 主动 flush 一次：用户填上 wechatName 后就尽快落库
      try {
        await queue.flushKey(activeKey);
      } catch {
        // 失败的话由 SaveQueue/SyncStatus 处理（Fix & retry）
      }
    },
    [activeKey, clients, clientId, queue, updateClient]
  );

  const onUpdateField = useCallback(
    (field: keyof ClientEntity, val: any) => {
      if (!clientId || !activeClient) return;

      const normalized = normalizeField(field, val);

      // --- Draft-only 阶段：wechatName 为空时，所有输入只写 draft，不触发任何 API/queue ---
      if (isDraftOnly && !isNonEmptyName(activeClient.wechatName) && field !== 'wechatName') {
        const next: ClientEntity = { ...activeClient, [field]: normalized } as ClientEntity;
        setDraft(clientId, next);
        return;
      }

      // draft-only 且正在编辑 wechatName：
      // - 先写入 draft
      // - 如果变成非空，立即 commit：把缓存的所有字段一次性落库
      if (isDraftOnly && field === 'wechatName') {
        const next: ClientEntity = { ...activeClient, wechatName: String(normalized ?? '') } as ClientEntity;
        setDraft(clientId, next);

        if (isNonEmptyName(next.wechatName)) {
          void commitDraftIfReady(next);
        }
        return;
      }

      // --- 已经进入“正式对象”（cache里有 / 或 draft 已有 wechatName）：随改随存 ---
      if (draft && draft.id === clientId && !fromCache) {
        // 边创建边编辑：把 draft 当 base，仍然允许 write-behind（此时 wechatName 已经非空）
        const next: ClientEntity = { ...(draft as ClientEntity), [field]: normalized } as ClientEntity;
        setDraft(clientId, next);
        updateClient(clientId, { [field]: normalized } as Partial<ClientEntity>, next);
        return;
      }

      updateClient(clientId, { [field]: normalized } as Partial<ClientEntity>);
    },
    [activeClient, clientId, commitDraftIfReady, draft, fromCache, isDraftOnly, setDraft, updateClient]
  );

  const retry = useCallback(async () => {
    if (!activeKey) return;
    await queue.flushKey(activeKey);
  }, [activeKey, queue]);

  const guardFn = useCallback(async () => {
    if (!activeKey) return true;

    // draft-only 且 wechatName 还空：不需要 flush，也不需要拦截
    const d = clientId ? getDraft(clientId) : null;
    const exists = clients.some((c) => c.id === clientId);
    if (d && !exists && !isNonEmptyName(d.wechatName)) return true;

    await queue.flushKey(activeKey);

    const post = queue.getSnapshot().keys.find((k) => k.key === activeKey);
    const blocked = post ? post.hasError || post.pending || post.inFlight : false;

    if (!blocked) return true;
    return window.confirm('Sync failed / pending. Leave this page anyway?');
  }, [activeKey, clientId, clients, getDraft, queue]);

  useEffect(() => {
    guard.setGuard(guardFn);
    return () => guard.setGuard(null);
  }, [guard, guardFn]);

  const onBack = useCallback(() => {
    void guard.run(
      () => nav('/clients'),
      () => {
        // 若仍未落库（draft-only），离开即丢弃（避免幽灵记录）
        const d = clientId ? getDraft(clientId) : null;
        const exists = clients.some((c) => c.id === clientId);
        if (d && !exists) clearDraft(clientId);
      }
    );
  }, [clearDraft, clientId, clients, getDraft, guard, nav]);

  if (!activeClient) return <div className="p-10">Loading...</div>;

  const financials = calculateFinancials(activeClient);

  return (
    <ClientDetailPage
      activeClient={activeClient}
      inventory={inventory}
      financials={financials}
      statusSteps={[...STATUS_STEPS]}
      busy={busy}
      hasError={hasError}
      flashSaved={flashSaved}
      onRetry={() => void retry()}
      onUpdateField={onUpdateField}
      onBack={onBack}
    />
  );
}

export function ClientsRoutes() {
  return (
    <DraftProvider>
      {/* list/detail 由 AppLegacy 的 Routes 控制 */}
      <div />
    </DraftProvider>
  );
}

// 供 AppLegacy 复用同一个 DraftProvider
export function ClientsDraftProvider({ children }: { children: React.ReactNode }) {
  return <DraftProvider>{children}</DraftProvider>;
}
